/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Expense, ExpenseFormData, Budget, BudgetFormData, MonthlySummary } from '../types';
import { getTodayDateString } from '../utils/helpers';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';

export class ApiService {
  private static instance: ApiService;
  private currentUserId: string | null = null;

  static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  setUserId(userId: string | null) {
    this.currentUserId = userId;
  }

  private getStorageKey(): string {
    if (!this.currentUserId) {
      throw new Error('User not authenticated');
    }
    return `onepocket_expenses_${this.currentUserId}`;
  }

  async addExpense(expenseData: ExpenseFormData): Promise<Expense> {
    // Note: We don't strictly need currentUserId since backend extracts it from JWT
    // But we keep the check for consistency with local storage fallback
    if (!this.currentUserId) {
      console.error('No currentUserId set, but continuing with JWT token');
    }

    // Prepare payload without ID or userId - backend will extract userId from JWT token
    const payload = {
      amount: parseFloat(expenseData.amount),
      reason: expenseData.reason,
      date: expenseData.date || getTodayDateString(),
      paymentMethod: expenseData.paymentMethod || 'upi',
      note: expenseData.note || '',
      reimbursable: expenseData.reimbursable || false
      // createdAt and userId will be generated by backend
    };

    try {
      const response = await this.makeRequest('/api/expenses', {
        method: 'POST',
        body: JSON.stringify(payload)
      });

      // Handle API doc structure - response has success and data fields
      if (response.success && response.data) {
        return response.data;
      }

      return response;
    } catch (error) {
      console.error('Failed to add expense:', error);

      // Fallback: create expense with temporary ID for local storage
      const tempExpense: Expense = {
        id: this.generateTempId(),
        amount: parseFloat(expenseData.amount),
        reason: expenseData.reason,
        date: expenseData.date || getTodayDateString(),
        createdAt: new Date().toISOString(),
        paymentMethod: expenseData.paymentMethod || 'upi',
        note: expenseData.note || '',
        reimbursable: expenseData.reimbursable || false
      };

      this.storeExpenseLocally(tempExpense);
      return tempExpense;
    }
  }

  private generateTempId(): string {
    // Temporary ID for offline storage (will be replaced by MongoDB ID when synced)
    return 'temp_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }

  async getExpenses(): Promise<Expense[]> {
    // If no auth token, return empty array (user not logged in)
    if (!this.hasAuthToken()) {
      return [];
    }

    try {
      // Get current month in YYYY-MM format
      const now = new Date();
      const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

      const response = await this.makeRequest(`/api/expenses?month=${currentMonth}`);
      // Handle API doc structure - response is array directly for GET /api/expenses
      return response || [];
    } catch (error) {
      console.error('Failed to fetch expenses:', error);
      // If API fails, return empty array for now (no local fallback without user)
      return [];
    }
  }

  async searchExpenses(query: string): Promise<Expense[]> {
    // If no auth token, return empty array (user not logged in)
    if (!this.hasAuthToken()) {
      return [];
    }

    try {
      const response = await this.makeRequest(`/api/expenses/search?query=${encodeURIComponent(query)}`);
      return response || [];
    } catch (error) {
      console.error('Failed to search expenses:', error);
      return [];
    }
  }

  async deleteExpense(expenseId: string): Promise<void> {
    try {
      await this.makeRequest(`/expenses/${expenseId}`, {
        method: 'DELETE'
      });
    } catch (error) {
      console.error('Failed to delete expense via API:', error);
    } finally {
      // Always remove from local storage regardless of API success/failure
      this.removeExpenseLocally(expenseId);
    }
  }

  private async makeRequest(endpoint: string, options?: RequestInit): Promise<any> {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getAuthToken()}`,
        ...options?.headers
      },
      ...options
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    return response.json();
  }


  private getAuthToken(): string {
    // Get JWT token from localStorage
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('No authentication token found');
    }
    return token;
  }

  private hasAuthToken(): boolean {
    return !!localStorage.getItem('auth_token');
  }

  private storeExpenseLocally(expense: Expense): void {
    const expenses = this.getLocalExpenses();
    expenses.push(expense);
    localStorage.setItem(this.getStorageKey(), JSON.stringify(expenses));
  }

  private getLocalExpenses(): Expense[] {
    try {
      const stored = localStorage.getItem(this.getStorageKey());
      return stored ? JSON.parse(stored) : [];
    } catch {
      return [];
    }
  }

  private removeExpenseLocally(expenseId: string): void {
    const expenses = this.getLocalExpenses();
    const filteredExpenses = expenses.filter(expense => expense.id !== expenseId);
    localStorage.setItem(this.getStorageKey(), JSON.stringify(filteredExpenses));
  }

  // Budget API methods
  async getBudgets(month?: string): Promise<Budget[]> {
    if (!this.hasAuthToken()) {
      return [];
    }

    try {
      // Default to current month if not provided
      const targetMonth = month || this.getCurrentMonth();
      const response = await this.makeRequest(`/api/budgets?month=${targetMonth}`);
      return response || [];
    } catch (error) {
      console.error('Failed to fetch budgets:', error);
      return [];
    }
  }

  private getCurrentMonth(): string {
    const now = new Date();
    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
  }

  async createBudget(budgetData: BudgetFormData): Promise<Budget> {
    const payload = {
      category: budgetData.category,
      amount: parseFloat(budgetData.amount),
      month: budgetData.month || this.getCurrentMonth()
    };

    try {
      const response = await this.makeRequest('/api/budgets', {
        method: 'POST',
        body: JSON.stringify(payload)
      });

      if (response.success && response.data) {
        return response.data;
      }
      return response;
    } catch (error) {
      console.error('Failed to create budget:', error);
      throw error;
    }
  }

  async updateBudget(budgetId: string, budgetData: BudgetFormData): Promise<Budget> {
    const payload = {
      category: budgetData.category,
      amount: parseFloat(budgetData.amount),
      month: budgetData.month || this.getCurrentMonth()
    };

    try {
      const response = await this.makeRequest(`/api/budgets/${budgetId}`, {
        method: 'PUT',
        body: JSON.stringify(payload)
      });

      if (response.success && response.data) {
        return response.data;
      }
      return response;
    } catch (error) {
      console.error('Failed to update budget:', error);
      throw error;
    }
  }

  async deleteBudget(budgetId: string): Promise<void> {
    try {
      await this.makeRequest(`/api/budgets/${budgetId}`, {
        method: 'DELETE'
      });
    } catch (error) {
      console.error('Failed to delete budget:', error);
      throw error;
    }
  }

  // History API methods
  async getMonthlySummary(month: string): Promise<MonthlySummary> {
    if (!this.hasAuthToken()) {
      throw new Error('Not authenticated');
    }

    try {
      const response = await this.makeRequest(`/api/history/summary?month=${month}`);
      return response;
    } catch (error) {
      console.error('Failed to fetch monthly summary:', error);
      throw error;
    }
  }

  async getAvailableMonths(): Promise<string[]> {
    if (!this.hasAuthToken()) {
      return [];
    }

    try {
      const response = await this.makeRequest('/api/history/months');
      return response || [];
    } catch (error) {
      console.error('Failed to fetch available months:', error);
      return [];
    }
  }
}

export const apiService = ApiService.getInstance();